<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F21%2F01%20-%20%E5%89%AF%E6%9C%AC%20(5)%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F21%2F01%20-%20%E5%89%AF%E6%9C%AC%20(4)%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F21%2F01%20-%20%E5%89%AF%E6%9C%AC%20(3)%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F21%2F01%20-%20%E5%89%AF%E6%9C%AC%20(2)%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F21%2F01%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F21%2F01%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[概述&emsp;&emsp;插入排序原理及优化。 原理&emsp;&emsp;从第二个元素开始，与前面的元素进行比较，若前一个元素小于后一个元素则交换位置，以此类推，最终取得结果。 Java实现123456789101112//插入排序 public static void insertion()&#123; int[] arr = &#123;9,6,1,5,3&#125;; for(int i=1;i&lt;arr.length;i++)&#123; for(int j=i;j&gt;0;j--)&#123; if(arr[j]&lt;arr[j-1])&#123; swop(arr,j,j-1); &#125; &#125; print(arr); &#125; &#125; 优化验证&emsp;&emsp;通过对数器验证算法正确性，获取对数器与计时器。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[概述&emsp;&emsp;冒泡排序原理及优化 原理&emsp;&emsp;从第一个元素开始，前一个元素与后一个元素比较大小，若是前一个元素大则交换位置，以此类推，直到将最大的元素推到最后。开始同样的第二轮比较直到将数组元素全部排列完毕。 Java实现1234567891011121314151617181920212223public static void bubble()&#123; int[] arr = &#123;9,6,1,5,3&#125;; for(int i=0,len = arr.length;i&lt;len-2;i++)&#123; for(int j=0;j&lt;len-1 ;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; swop(arr,j,j+1); &#125; print(arr); &#125; &#125; &#125;public static void swop(int[] arr,int i,int j)&#123; int temp; temp = arr[j]; arr[j] = arr[i]; arr[i] = temp;&#125;public static void print(int[] arr)&#123; for(int i=0;i&lt;arr.length;i++)&#123; System.out.print(arr[i]+&quot; &quot;); &#125; System.out.println();&#125; 优化&emsp;&emsp;从上面代码可以看出在经过两层循环后，该算法的时间复杂度为$n^2$,现对该算法进行如下优化： 验证&emsp;&emsp;通过对数器验证算法正确性，获取对数器与计时器。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2019%2F04%2F08%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[概述&emsp;&emsp;选择排序的原理以及优化。 原理&emsp;&emsp;以将int数组中的数据降序排列为例，其原理是将第一个元素与后续的元素进行比较，当遇到较大的元素时就使用较大的元素向后继续比较，直到一轮遍历结束后找到最大的元素，然后再交换第一个元素与这个最大元素的位置。接着开始第二轮遍历，从第二个元素开始，以之前的方式遍历，最后得到结果。 Java实现12345678910111213141516171819202122232425//选择排序 public static void selection()&#123; int[] arr = &#123;6,5,7,9,1,3,2,8,4&#125;; print(arr); for(int i=0,len = arr.length-1;i&lt;len;i++)&#123; int maxPos = i; for(int j=i+1,len2=arr.length;j&lt;len2;j++)&#123; maxPos=arr[maxPos]&lt;arr[j]?j:maxPos; &#125; swop(arr,i,maxPos); &#125; print(arr); &#125; public static void swop(int[] arr,int i,int j)&#123; int temp; temp = arr[j]; arr[j] = arr[i]; arr[i] = temp; &#125; public static void print(int[] arr)&#123; for(int i=0;i&lt;arr.length;i++)&#123; System.out.print(arr[i]+&quot; &quot;); &#125; System.out.println(); &#125; 通过上面代码可在控制台打印出“9 8 7 6 5 4 3 2 1”。成功的将数组降序排列。 优化方法一每次遍历时同时找出最小值和最大值，以此来减少遍历次数。将selection方法修改为如下代码：1//选择排序 方法二每次比较时先比较后面两个元素的大小。 验证&emsp;&emsp;通过对数器验证算法正确性，获取对数器与计时器。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十大排序算法]]></title>
    <url>%2F2019%2F04%2F07%2F%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[概述&emsp;&emsp;归纳常见的十大排序算法。 常见的排序表格 中文名称 英文名称 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性 选择排序 selection $n^2$ $n^2$ $n^2$ 1 不稳 冒泡排序 bubble $n^2$ $n^2$ $n$ 1 稳 插入排序 insertion $n^2$ $n^2$ $n$ 1 稳 堆排序 heap $nlog_2^n$ $nlog_2^n$ $nlog_2^n$ 1 不稳 希尔排序 shell $n^{1.3}$ $n^2$ $n$ 1 不稳 归并排序 merge $nlog_2^n$ $nlog_2^n$ $nlog_2^n$ $n$ 稳 快速排序 quick $nlog_2^n$ $n^2$ $nlog_2^n$ $log_2^n$ 不稳 桶排序 bucket $n+k$ $n^2$ $n$ $n+k$ 稳 计数排序 counting $n+k$ $n+k$ $n+k$ $n+k$ 稳 基数排序 radix $n·k$ $n·k$ $n·k$ $n+k$ 稳 平均时间复杂度&emsp;&emsp;对于时间复杂度函数比较&emsp;&emsp;Ο($1$)＜Ο($log_2^n$)＜Ο($n$)＜Ο($nlog_2^n$)＜Ο($n^2$)＜Ο($n^3$)＜…＜Ο($2^n$)＜Ο($n!$) 对数器与计时器&emsp;&emsp;因为肉眼很多东西是看不出来的，比如算法的稳定性，当数据大到一定程度时用肉眼看及其容易出错，因此引用了对数器来对程序的正确性进行分析。用计时器可查看函数运行时间，可以更直观的看出代码的执行效率，以下为对数器与计时器代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private static int bound = 10000;//随机数组样本大小public static void arithmetic(int[] arr)&#123; //需要执行的函数 &#125;//对数器public static boolean logarithmicDetector()&#123; boolean result = true; out: for(int j=0;j&lt;100;j++)&#123; int[] arr = createArr(bound); int[] arr2 = Arrays.copyOf(arr, bound); Arrays.sort(arr); arithmetic(arr2); for(int i=0;i&lt;bound;i++)&#123; if(arr[i]!=arr2[i])&#123; result = false; break out; &#125; &#125; &#125; System.out.println(&quot;该算法&quot;+(result?&quot;正确&quot;:&quot;错误&quot;)); return result; &#125; //计时器 public static void timer()&#123; int[] createArr = createArr(bound); long start = System.currentTimeMillis(); arithmetic(createArr); System.out.println(&quot;单次排序时间为：&quot;+(System.currentTimeMillis()-start)+&quot;ms&quot;); &#125; //创建随机样本数组 public static int[] createArr(int bound)&#123; System.out.println(&quot;开始创建随机数组，数组大小：&quot;+bound); Random random = new Random(); int[] arr = new int[bound]; for(int i=0;i&lt;bound;i++)&#123; arr[i]=random.nextInt(bound); &#125; System.out.println(&quot;随机数组创建完毕&quot;); return arr; &#125; //启动方法 public static void main(String[] args) &#123; if(logarithmicDetector()) timer(); &#125; &emps;&emps;只需要创建一个类，将上面代码复制进去，在arithmetic方法中调用需要测试的算法即可。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程之Thread中各方法的解析记录（一）]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThread%E4%B8%AD%E5%90%84%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述&emsp;&emsp;本系列文章主要是对阅读《java多线程核心技术》后的总结以及对线程API的归纳并对我所认为重要的内容进行记录，方便日后查看。 Thread与Thread对象线程类中Thread.方法与thread.方法的区别：前者主要是对执行代码的线程进行操作，而后者则是对该线程对象进行操作。对于Thread.currentThread()获取的是执行当前代码的线程。对于创建的MyThread而言，执行它构造方法的是线程main，而执行run方法的是线程myThread。 验证代码如下：12345678910111213141516171819//创建一个线程类public class MyThread extends Thread&#123; public MyThread(String name)&#123; System.out.println(&quot;执行构造方法的线程：&quot;+Thread.currentThread().getName()); super.setName(name); &#125; public void run()&#123; System.out.println(&quot;执行run方法的线程：&quot;+Thread.currentThread().getName()); &#125;&#125;//测试类public class Test&#123; public static void main(String[] args)&#123; MyThread mt = new MyThread(&quot;myThread&quot;); mt.start(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO流原理总结]]></title>
    <url>%2F2019%2F03%2F29%2FIO%E6%B5%81%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述&emsp;&emsp;通过对IO流的学习进行总结，深入了解IO流底层工作原理。 对流的分类&emsp;&emsp;流总体来说可以以两种分类方式进行分类。按输入输入来分可分为输入流与输出流，按字符来分可分为字节流以及字符流。 字节流&emsp;&emsp;字节流以字节的方式进行输入输出，对图像或是影像的复制一般是使用字节流实现的。 输入字节流&emsp;&emsp;输入字节流是通过继承InputStream类实现的，这里主要以FileInputStream为例： 创建一个读取文件的测试类：123456789101112131415161718192021222324public class IOTest &#123; public static void main(String[] agrs) throws IOException&#123; String text = readFile(); System.out.println(text); &#125; //读取文件 public static String inputFile() throws IOException&#123; //获取资源文件 File file = new File(&quot;C:/Users/Soloporvagancia/Desktop/新建文件夹/EE/inputText.txt&quot;); //创建输入流 FileInputStream fis = new FileInputStream(file); //创建一个byte数组用于缓冲 byte[] buf = new byte[1024]; int len = 0; StringBuffer sb = new StringBuffer(); while((len = fis.read(buf))!=-1)&#123; sb.append(new String(buf,0,len)); &#125; //关闭资源 fis.close(); return sb.toString(); &#125;&#125; &emsp;&emsp;对于字节流在读取文件时都是一个字节一个字节的读取数据，这样照成效率低下，因此引入了缓冲区，利用byte数组先存值，然后再一次将数组的内容取出处理，这里数组的大小可以根据实际业务场景进行修改。读取完文件后一定要记得将资源关闭，否则其他程序无法对该资源文件进行其他操作。 输出字节流&emsp;&emsp;输出字节流通过继承OutputStream类实现，以FileOutputStream为例： 在上IOTest测试类中新增方法outputFile()1234567891011121314//输出文件public static void outputFile()&#123; //获取输出文件，若是该路径下无该文件则自动创建 File file = new File(&quot;C:/Users/Soloporvagancia/Desktop/新建文件夹/EE/outputText.txt&quot;); String text = &quot;abc&quot;; //创建输出流 FileOutputStream fos = new FileOutputStream(file); //创建缓冲数组 byte[] buf = text.getBytes(); //将数据写出 fos.write(buf); //关闭资源 fos.close();&#125; &emsp;&emsp;与输入字节流类似，输出字节流每次只能write一个字节，因此同样通过引入缓冲数组来提交写的效率。需要注意的是使用FileOutputStream写数据时，默认会将原文件覆盖，若是想追加内容应该用FileOutputStream的另一个构造函数FileOutputStream(File file, boolean append),当append为true时追加内容。 字符流&emsp;&emsp;字符流的特点是可以直接输出中文。字符流相对于字节流来说是多了一个编码与解码过程。 输入字符流输入字符流的基类为Reader，此处以FileReader为例：123456789101112131415161718//字符流读取文件public static void readFile() throws IOException&#123; //获取需要读取的文件 File file = new File(&quot;C:/Users/Soloporvagancia/Desktop/新建文件夹/EE/readText.txt&quot;); //创建输入字符流 FileReader fr = new FileReader(file); //创建缓冲流 BufferedReader br = new BufferedReader(fr); StringBuffer sb = new StringBuffer(); String line = &quot;&quot;; //读取数据 while((line = br.readLine())!=null)&#123; sb.append(line); &#125; System.out.print(sb.toString()); //关闭资源 br.close();&#125; &emsp;&emsp;输入字符流同输入字节流类似，都可以用缓冲数组实现，这里直接使用BufferedReader缓冲流。 输出字符流12345678910111213//字符流输出文件public static void writeFile() throws IOException&#123; //需要写入的数据 String text = &quot;这里是需要写入的内容&quot;; //获取需要写入的文件 File file = new File(&quot;C:/Users/Soloporvagancia/Desktop/新建文件夹/EE/writeText.txt&quot;); //创建输出字符流 FileWriter fw = new FileWriter(file); //输出数据 fw.write(text); //关闭资源 fw.close();&#125; &emsp;&emsp;FileWriter中维护了一个字节数组，写数据会先写到它内部的字节数组中，如果需要真正的的输出到硬盘上是需要执行flush()或close()方法或当字节数组满时才输出。 缓冲流&emsp;&emsp;对于输入输出流来说，因为都是一个字节一个字节的输入或输出数据的，因此使用缓冲的方式提高效率，除了用上面的byte数组作为缓冲区外还可以通过使用BufferedInputStream,BufferedOutputStream这两个类来实现缓冲区的功能。在IOTest测试类中添加以下两个方法：123456789101112131415161718192021222324252627282930313233//通过BufferedInputStream读取文件public static void bufInputFile() throws IOException&#123; //获取需要读取的文件 File file = new File(&quot;C:/Users/Soloporvagancia/Desktop/新建文件夹/EE/inputText.txt&quot;); //创建输入流 FileInputStream fis = new FileInputStream(file); //创建缓冲流 BufferedInputStream bis = new BufferedInputStream(fis); StringBuffer sb = new StringBuffer(); int content=0; //读取数据 while((content = bis.read())!=-1)&#123; System.out.print((char)content); &#125; //关闭资源 bis.close();&#125;//通过BufferedOutputStream输出文件public static void bufOutputFile() throws IOException&#123; //需要输出的数据 String text = &quot;abc&quot;; //获取需要输出的文件 File file = new File(&quot;C:/Users/Soloporvagancia/Desktop/新建文件夹/EE/outputText.txt&quot;); //创建输出流 FileOutputStream fos = new FileOutputStream(file); //创建缓冲流 BufferedOutputStream bos = new BufferedOutputStream(fos); //输出数据 bos.write(text.getBytes()); //关闭资源 bos.close();&#125; &emsp;&emsp;从这两个方法来看，使用缓冲区似乎没有什么不一样的地方，读取文本时BufferedInputStream与FileInputStream一样一次只能读取一个字节。通过阅读BufferedInputStream发现,在BufferedInputStream中同样维护了一个字节数组，默认大小为8kb,之所以能提高效率是因为FileInputStream是从硬盘中将数据一个一个读取出来的，而BufferedInputStream是先将数据加载到内存中再一个一个取出来的。因为从内存中直接加载数据要比从硬盘中加载数据来的快，所以BufferedInputStream效率高。BufferedOutputStream同理，也是将数据先放进缓冲数组中，只有执行flush()或close()或内部维护的字节数组满了这三种情况才写入到硬盘中。&emsp;&emsp;上面两个方法之所以没有关闭输入输出流是因为在BufferedInputStream与BufferedOutputStream的源码中close()方法就是用来关闭输入输出流的方法。&emsp;&emsp;BufferedReader原理也是一样，只不过BufferedReader维护的是字符数组，其他原理是一样的。此外BufferedReader还提供了readLine()方法能够一次读取一行。同理，BufferedWriter也是维护了一个8kb的字符数组，并且提供了newLine()方法在输出的时候换行。 转换流&emsp;&emsp;转换流用于将字节流转换为字符流以满足特定场景的需要。输入字节流转换为字符流使用InputStreamReader，输出字节流转换为字符流使用OutputStreamWriter,它们的基类分别为Readery与Writer。以下两个方法即为转为转换流的使用方法：1234567891011121314151617181920212223242526272829//输入字节流转换为输入字符流public static void byteToCharReadText() throws IOException&#123; File file = new File(&quot;C:/Users/Soloporvagancia/Desktop/新建文件夹/EE/readText.txt&quot;); FileInputStream fis = new FileInputStream(file); //将字节流转换为字符流 InputStreamReader isr = new InputStreamReader(fis);//InputStreamReader(InputStream in, String charsetName)构造方法可指定使用的码表 //使用缓冲流 BufferedReader br = new BufferedReader(isr); StringBuffer sb = new StringBuffer(); String line = &quot;&quot;; while((line = br.readLine())!=null)&#123; sb.append(line); &#125; System.out.print(sb.toString()); br.close(); fis.close();&#125;//输出字节流转换为输出字符流public static void charToByteWriteText() throws IOException&#123; String text = &quot;输出字节流转换为输出字符流&quot;; File file = new File(&quot;C:/Users/Soloporvagancia/Desktop/新建文件夹/EE/writeText.txt&quot;); FileOutputStream fos = new FileOutputStream(file); OutputStreamWriter osw = new OuputStreamWriter(fos);//OutputStreamWriter(OutputStream out, String charsetName)构造方法可指定使用的码表 BufferedWriter bw = new BufferedWriter(osw); bw.write(text); bw.close(); fos.close();&#125; 编码与解码&emsp;&emsp;在读取或输出文件时经常会出现乱码的现象，其主要原因就是编码与解码所用的码表不一致。只有当编码与解码所用码表保持一致时才不会乱码，现在普遍使用UTF-8进行编码与解码。 关闭资源&emsp;&emsp;在对流操作后应当及时关闭资源，关闭资源应先开后关，后开先关。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的语法记录]]></title>
    <url>%2F2019%2F02%2F12%2FMarkdown%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[概述&emsp;&emsp;本篇博客主要用于记录Markdown常用语法，方便日后查看。 一、标题标题前加上“#”号，通常一个“#”号表示为一级标题，两个即为二级标题以此类推。 示例：## 标题 二、字体加粗：在要加粗的文字两边加上两个“*”号。示例：**加粗** 效果： 加粗 斜体：在文字两边加上一个“*”号。示例：*斜体* 效果：斜体 斜体加粗：在文字两边加上三个“*”号。示例：***斜体加粗*** 效果：斜体加粗 删除线：在文字两边加上两个“~”号。示例：~删除线~ 效果： 删除线 三、引用在文字前添加“&gt;”表示引用 示例: &gt;引用 四、分割线三个“-”或“*”以上可作为分割线 示例：--- 或 *** 五、图片语法：![图片alt](图片地址 &quot;图片title&quot;) 六、超链接语法：[超链接名称](超链接地址 &quot;超链接title&quot;)示例：我的博客 Markdown语法本身并不支持打开新的页面，若是想打开新的页面可以用HTML的a标签实现语法：&lt;a href=&quot;超链接地址&quot;&gt;我的博客&lt;/a&gt;示例：我的博客 七、列表无序列表 语法：无序列表用“-+*”都可以123- 列表内容+ 列表内容* 列表内容 示例： 列表内容 列表内容 有序列表 语法：数字加点，如需要二级内容则在数字前加三个空格如 123451. 列表内容2. 列表内容 2.1 列表内容3. 列表内容 示例: 列表内容 列表内容 2.1 列表内容 列表内容 八、表格语法：12345678姓名|班级|学号 --|:--:|--:张三|一班|01李四|二班|01文字默认居左-两边加：表示文字居中-右边加：表示文字居右 示例： 姓名 班级 学号 张三 一班 01 李四 二班 01 九、代码语法：单行就是两个反引号 ``，多行就是三个反引号``` 十、其他Markdown支持内嵌HTML标签，如上用的a标签以及改变字体的font标签并且支持js 以上即为Markdown相对常用的一些语法，若有遗漏日后补充]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
