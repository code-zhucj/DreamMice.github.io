<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[多线程之Thread中各方法的解析记录（一）]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThread%E4%B8%AD%E5%90%84%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述&emsp;&emsp;本系列文章主要是对阅读《java多线程核心技术》后的总结以及对线程API的归纳并对我所认为重要的内容进行记录，方便日后查看。 Thread与Thread对象线程类中Thread.方法与thread.方法的区别：前者主要是对执行代码的线程进行操作，而后者则是对该线程对象进行操作。对于Thread.currentThread()获取的是执行当前代码的线程。对于创建的MyThread而言，执行它构造方法的是线程main，而执行run方法的是线程myThread。 验证代码如下：12345678910111213141516171819//创建一个线程类public class MyThread extends Thread&#123; public MyThread(String name)&#123; System.out.println(&quot;执行构造方法的线程：&quot;+Thread.currentThread().getName()); super.setName(name); &#125; public void run()&#123; System.out.println(&quot;执行run方法的线程：&quot;+Thread.currentThread().getName()); &#125;&#125;//测试类public class Test&#123; public static void main(String[] args)&#123; MyThread mt = new MyThread(&quot;myThread&quot;); mt.start(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO流原理总结]]></title>
    <url>%2F2019%2F03%2F29%2FIO%E6%B5%81%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述&emsp;&emsp;通过对IO流的学习进行总结，深入了解IO流底层工作原理。 对流的分类&emsp;&emsp;流总体来说可以以两种分类方式进行分类。按输入输入来分可分为输入流与输出流，按字符来分可分为字节流以及字符流。 字节流&emsp;&emsp;字节流以字节的方式进行输入输出，对图像或是影像的复制一般是使用字节流实现的。 输入字节流&emsp;&emsp;输入字节流是通过继承InputStream类实现的，这里主要以FileInputStream为例： 创建一个读取文件的测试类：123456789101112131415161718192021222324public class IOTest &#123; public static void main(String[] agrs) throws IOException&#123; String text = readFile(); System.out.println(text); &#125; //读取文件 public static String inputFile() throws IOException&#123; //获取资源文件 File file = new File(&quot;C:/Users/Soloporvagancia/Desktop/新建文件夹/EE/inputText.txt&quot;); //创建输入流 FileInputStream fis = new FileInputStream(file); //创建一个byte数组用于缓冲 byte[] buf = new byte[1024]; int len = 0; StringBuffer sb = new StringBuffer(); while((len = fis.read(buf))!=-1)&#123; sb.append(new String(buf,0,len)); &#125; //关闭资源 fis.close(); return sb.toString(); &#125;&#125; &emsp;&emsp;对于字节流在读取文件时都是一个字节一个字节的读取数据，这样照成效率低下，因此引入了缓冲区，利用byte数组先存值，然后再一次将数组的内容取出处理，这里数组的大小可以根据实际业务场景进行修改。读取完文件后一定要记得将资源关闭，否则其他程序无法对该资源文件进行其他操作。 输出字节流&emsp;&emsp;输出字节流通过继承OutputStream类实现，以FileOutputStream为例： 在上IOTest测试类中新增方法outputFile()1234567891011121314//输出文件public static void outputFile()&#123; //获取输出文件，若是该路径下无该文件则自动创建 File file = new File(&quot;C:/Users/Soloporvagancia/Desktop/新建文件夹/EE/outputText.txt&quot;); String text = &quot;abc&quot;; //创建输出流 FileOutputStream fos = new FileOutputStream(file); //创建缓冲数组 byte[] buf = text.getBytes(); //将数据写出 fos.write(buf); //关闭资源 fos.close();&#125; &emsp;&emsp;与输入字节流类似，输出字节流每次只能write一个字节，因此同样通过引入缓冲数组来提交写的效率。需要注意的是使用FileOutputStream写数据时，默认会将原文件覆盖，若是想追加内容应该用FileOutputStream的另一个构造函数FileOutputStream(File file, boolean append),当append为true时追加内容。 字符流&emsp;&emsp;字符流的特点是可以直接输出中文。字符流相对于字节流来说是多了一个编码与解码过程。 输入字符流输入字符流的基类为Reader，此处以FileReader为例：123456789101112131415161718//字符流读取文件public static void readFile() throws IOException&#123; //获取需要读取的文件 File file = new File(&quot;C:/Users/Soloporvagancia/Desktop/新建文件夹/EE/readText.txt&quot;); //创建输入字符流 FileReader fr = new FileReader(file); //创建缓冲流 BufferedReader br = new BufferedReader(fr); StringBuffer sb = new StringBuffer(); String line = &quot;&quot;; //读取数据 while((line = br.readLine())!=null)&#123; sb.append(line); &#125; System.out.print(sb.toString()); //关闭资源 br.close();&#125; &emsp;&emsp;输入字符流同输入字节流类似，都可以用缓冲数组实现，这里直接使用BufferedReader缓冲流。 输出字符流12345678910111213//字符流输出文件public static void writeFile() throws IOException&#123; //需要写入的数据 String text = &quot;这里是需要写入的内容&quot;; //获取需要写入的文件 File file = new File(&quot;C:/Users/Soloporvagancia/Desktop/新建文件夹/EE/writeText.txt&quot;); //创建输出字符流 FileWriter fw = new FileWriter(file); //输出数据 fw.write(text); //关闭资源 fw.close();&#125; &emsp;&emsp;FileWriter中维护了一个字节数组，写数据会先写到它内部的字节数组中，如果需要真正的的输出到硬盘上是需要执行flush()或close()方法或当字节数组满时才输出。 缓冲流&emsp;&emsp;对于输入输出流来说，因为都是一个字节一个字节的输入或输出数据的，因此使用缓冲的方式提高效率，除了用上面的byte数组作为缓冲区外还可以通过使用BufferedInputStream,BufferedOutputStream这两个类来实现缓冲区的功能。在IOTest测试类中添加以下两个方法：123456789101112131415161718192021222324252627282930313233//通过BufferedInputStream读取文件public static void bufInputFile() throws IOException&#123; //获取需要读取的文件 File file = new File(&quot;C:/Users/Soloporvagancia/Desktop/新建文件夹/EE/inputText.txt&quot;); //创建输入流 FileInputStream fis = new FileInputStream(file); //创建缓冲流 BufferedInputStream bis = new BufferedInputStream(fis); StringBuffer sb = new StringBuffer(); int content=0; //读取数据 while((content = bis.read())!=-1)&#123; System.out.print((char)content); &#125; //关闭资源 bis.close();&#125;//通过BufferedOutputStream输出文件public static void bufOutputFile() throws IOException&#123; //需要输出的数据 String text = &quot;abc&quot;; //获取需要输出的文件 File file = new File(&quot;C:/Users/Soloporvagancia/Desktop/新建文件夹/EE/outputText.txt&quot;); //创建输出流 FileOutputStream fos = new FileOutputStream(file); //创建缓冲流 BufferedOutputStream bos = new BufferedOutputStream(fos); //输出数据 bos.write(text.getBytes()); //关闭资源 bos.close();&#125; &emsp;&emsp;从这两个方法来看，使用缓冲区似乎没有什么不一样的地方，读取文本时BufferedInputStream与FileInputStream一样一次只能读取一个字节。通过阅读BufferedInputStream发现,在BufferedInputStream中同样维护了一个字节数组，默认大小为8kb,之所以能提高效率是因为FileInputStream是从硬盘中将数据一个一个读取出来的，而BufferedInputStream是先将数据加载到内存中再一个一个取出来的。因为从内存中直接加载数据要比从硬盘中加载数据来的快，所以BufferedInputStream效率高。BufferedOutputStream同理，也是将数据先放进缓冲数组中，只有执行flush()或close()或内部维护的字节数组满了这三种情况才写入到硬盘中。&emsp;&emsp;上面两个方法之所以没有关闭输入输出流是因为在BufferedInputStream与BufferedOutputStream的源码中close()方法就是用来关闭输入输出流的方法。&emsp;&emsp;BufferedReader原理也是一样，只不过BufferedReader维护的是字符数组，其他原理是一样的。此外BufferedReader还提供了readLine()方法能够一次读取一行。同理，BufferedWriter也是维护了一个8kb的字符数组，并且提供了newLine()方法在输出的时候换行。 转换流&emsp;&emsp;转换流用于将字节流转换为字符流以满足特定场景的需要。输入字节流转换为字符流使用InputStreamReader，输出字节流转换为字符流使用OutputStreamWriter,它们的基类分别为Readery与Writer。以下两个方法即为转为转换流的使用方法：1234567891011121314151617181920212223242526272829//输入字节流转换为输入字符流public static void byteToCharReadText() throws IOException&#123; File file = new File(&quot;C:/Users/Soloporvagancia/Desktop/新建文件夹/EE/readText.txt&quot;); FileInputStream fis = new FileInputStream(file); //将字节流转换为字符流 InputStreamReader isr = new InputStreamReader(fis);//InputStreamReader(InputStream in, String charsetName)构造方法可指定使用的码表 //使用缓冲流 BufferedReader br = new BufferedReader(isr); StringBuffer sb = new StringBuffer(); String line = &quot;&quot;; while((line = br.readLine())!=null)&#123; sb.append(line); &#125; System.out.print(sb.toString()); br.close(); fis.close();&#125;//输出字节流转换为输出字符流public static void charToByteWriteText() throws IOException&#123; String text = &quot;输出字节流转换为输出字符流&quot;; File file = new File(&quot;C:/Users/Soloporvagancia/Desktop/新建文件夹/EE/writeText.txt&quot;); FileOutputStream fos = new FileOutputStream(file); OutputStreamWriter osw = new OuputStreamWriter(fos);//OutputStreamWriter(OutputStream out, String charsetName)构造方法可指定使用的码表 BufferedWriter bw = new BufferedWriter(osw); bw.write(text); bw.close(); fos.close();&#125; 编码与解码&emsp;&emsp;在读取或输出文件时经常会出现乱码的现象，其主要原因就是编码与解码所用的码表不一致。只有当编码与解码所用码表保持一致时才不会乱码，现在普遍使用UTF-8进行编码与解码。 关闭资源&emsp;&emsp;在对流操作后应当及时关闭资源，关闭资源应先开后关，后开先关。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的语法记录]]></title>
    <url>%2F2019%2F02%2F12%2FMarkdown%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[概述&emsp;&emsp;本篇博客主要用于记录Markdown常用语法，方便日后查看。 一、标题标题前加上“#”号，通常一个“#”号表示为一级标题，两个即为二级标题以此类推。 示例：## 标题 二、字体加粗：在要加粗的文字两边加上两个“*”号。示例：**加粗** 效果： 加粗 斜体：在文字两边加上一个“*”号。示例：*斜体* 效果：斜体 斜体加粗：在文字两边加上三个“*”号。示例：***斜体加粗*** 效果：斜体加粗 删除线：在文字两边加上两个“~”号。示例：~删除线~ 效果： 删除线 三、引用在文字前添加“&gt;”表示引用 示例: &gt;引用 四、分割线三个“-”或“*”以上可作为分割线 示例：--- 或 *** 五、图片语法：![图片alt](图片地址 &quot;图片title&quot;) 六、超链接语法：[超链接名称](超链接地址 &quot;超链接title&quot;)示例：我的博客 Markdown语法本身并不支持打开新的页面，若是想打开新的页面可以用HTML的a标签实现语法：&lt;a href=&quot;超链接地址&quot;&gt;我的博客&lt;/a&gt;示例：我的博客 七、列表无序列表 语法：无序列表用“-+*”都可以123- 列表内容+ 列表内容* 列表内容 示例： 列表内容 列表内容 有序列表 语法：数字加点，如需要二级内容则在数字前加三个空格如 123451. 列表内容2. 列表内容 2.1 列表内容3. 列表内容 示例: 列表内容 列表内容 2.1 列表内容 列表内容 八、表格语法：12345678姓名|班级|学号 --|:--:|--:张三|一班|01李四|二班|01文字默认居左-两边加：表示文字居中-右边加：表示文字居右 示例： 姓名 班级 学号 张三 一班 01 李四 二班 01 九、代码语法：单行就是两个反引号 ``，多行就是三个反引号``` 十、其他Markdown支持内嵌HTML标签，如上用的a标签以及改变字体的font标签并且支持js 以上即为Markdown相对常用的一些语法，若有遗漏日后补充]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
